"__kernel void matmult( __global float *A,__global float *B,__global float *C, __global int * num  ) \n"
"{ \n"
" int size1=get_global_size(0)/2 ;\n"
" int size2 =get_global_size(1)/2 ; \n"
" int size3 = get_global_size(0)/2*get_global_size(1)/2;  \n"
" __local float  tileA[size1]; \n"
" __local float  tileB[size2]; \n"
" __local float  tileB2[size2]; \n"
" __local float  tileC[size3]; \n"
" int h1=0;\n"
" int h2=0; \n"
" if (get_global_id(0) > size1 -1){\n"
 "  h1=1; \n"
 "  } \n"
 "  if (get_global_id(1) > size2 -1){ \n"
 "  h2=1; \n"
 "  } \n"
 " int NWITEMS = num[0]; \n"
 "for (hh=0; hh<2; hh++){ \n"
 " for (int j=0; j< size1; j++) { \n"
"event_t ev[2]; \n"
" ev[0] = async_work_group_copy(tileA, A[(j+h1*size1)*NWITEMS+hh*NWITEMS/2], NWTEMS/2,0); \n"
" ev[1]= async_work_group_copy(tileB, B[(j+hh*NWITEMS/2)*get_global_size(1)+h1*size2], size2,0); \n"
"wait_group_events(2,ev ); \n"

" } \n"

" float loc=0; \n"

" for (int i=0; i < NWITEMS/2; i++) { \n"
" loc+= tileA[get_global_id(0)%(NWITEMS/2)*NWITEMS/2+i]*tileB[i*get_global_size(1)/2+get_global_id(1)%(get_global_size(1)/2)]; \n"
" } \n"
"tileC[get_global_id(0)%(get_global_size(0)/2)*get_global_size(1)/2+get_global_id(1)%(get_global_size(1)/2)]+=loc; /n"
"} \n"
"barrier(CLK_LOCAL_MEM_FENCE); \n"
 " for (int j=0; j< size1; j++) { \n"
"event_t ev[1]; \n"
" ev[0] = async_work_group_copy(tileC[(j*size2)],C[(j+h1*size1)*get_global_size(1)+h2*size2], size2,0); \n"
"wait_group_events(1,ev ); \n"

" } \n"